/**
 * Nautilus Intelligence Core - Automatic PR Creation Module
 * 
 * Creates automated Pull Requests via GitHub API when issues are detected
 */

import { Octokit } from 'octokit';
import type { FixSuggestion } from './suggestFix';
import type { AnalysisResult } from './analyzer';

export interface PRCreationResult {
  success: boolean;
  prNumber?: number;
  prUrl?: string;
  error?: string;
}

/**
 * Creates an automated Pull Request with fix suggestions
 */
export async function createAutoPR(
  suggestion: FixSuggestion,
  analysis: AnalysisResult,
  options: {
    owner?: string;
    repo?: string;
    baseBranch?: string;
    headBranch?: string;
  } = {}
): Promise<PRCreationResult> {
  const {
    owner = process.env.GITHUB_REPOSITORY_OWNER || 'RodrigoSC89',
    repo = process.env.GITHUB_REPOSITORY_NAME || 'travel-hr-buddy',
    baseBranch = 'main',
    headBranch = 'ai/autofix-' + Date.now()
  } = options;

  // Check if GitHub token is available
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    console.error('âŒ GITHUB_TOKEN not found. Cannot create PR.');
    return {
      success: false,
      error: 'GITHUB_TOKEN environment variable is required'
    };
  }

  try {
    const octokit = new Octokit({ auth: token });

    // Build comprehensive PR body
    const prBody = buildPRBody(suggestion, analysis);

    console.log(`ğŸš€ Creating automated PR...`);
    console.log(`   Owner: ${owner}`);
    console.log(`   Repo: ${repo}`);
    console.log(`   Base: ${baseBranch}`);
    console.log(`   Head: ${headBranch}`);

    // Create the PR
    const response = await octokit.request('POST /repos/{owner}/{repo}/pulls', {
      owner,
      repo,
      title: suggestion.title,
      head: headBranch,
      base: baseBranch,
      body: prBody,
      headers: {
        'X-GitHub-Api-Version': '2022-11-28'
      }
    });

    console.log(`âœ… PR created successfully!`);
    console.log(`   Number: #${response.data.number}`);
    console.log(`   URL: ${response.data.html_url}`);

    return {
      success: true,
      prNumber: response.data.number,
      prUrl: response.data.html_url
    };
  } catch (error: any) {
    console.error('âŒ Failed to create PR:', error.message);
    
    // Handle specific error cases
    if (error.status === 404) {
      return {
        success: false,
        error: 'Repository not found or insufficient permissions'
      };
    } else if (error.status === 422) {
      return {
        success: false,
        error: 'Branch does not exist or PR already exists'
      };
    }

    return {
      success: false,
      error: error.message || 'Unknown error occurred'
    };
  }
}

/**
 * Builds the PR body with detailed information
 */
function buildPRBody(suggestion: FixSuggestion, analysis: AnalysisResult): string {
  const { findings } = analysis;
  
  let body = `## ğŸ¤– Nautilus Intelligence Core - Automated Fix Suggestion\n\n`;
  
  body += `> **Generated by:** Nautilus Intelligence Core\n`;
  body += `> **Workflow:** ${analysis.workflowName}\n`;
  body += `> **Run ID:** ${analysis.workflowRun}\n`;
  body += `> **Timestamp:** ${analysis.timestamp}\n`;
  body += `> **Priority:** ${suggestion.priority.toUpperCase()}\n\n`;

  body += `---\n\n`;

  body += `### ğŸ“‹ Problem Analysis\n\n`;
  body += `${suggestion.description}\n\n`;

  body += `### ğŸ” Issues Detected (${findings.length})\n\n`;
  findings.forEach((finding, index) => {
    const emoji = getSeverityEmoji(finding.severity);
    body += `${index + 1}. ${emoji} **${finding.message}**\n`;
    body += `   - **Type:** \`${finding.type}\`\n`;
    body += `   - **Severity:** \`${finding.severity}\`\n`;
    body += `   - **Pattern:** ${finding.pattern}\n`;
    
    if (finding.context) {
      body += `   - **Context:**\n   \`\`\`\n   ${finding.context.substring(0, 300)}\n   \`\`\`\n`;
    }
    body += `\n`;
  });

  body += `### ğŸ”§ Suggested Changes\n\n`;
  body += `${suggestion.suggestedChanges}\n\n`;

  body += `### ğŸ“Š Expected Impact\n\n`;
  body += `${suggestion.estimatedImpact}\n\n`;

  body += `---\n\n`;
  body += `### âš ï¸ Important Notes\n\n`;
  body += `- This PR was automatically generated by Nautilus Intelligence Core\n`;
  body += `- Please review the changes carefully before merging\n`;
  body += `- Run all tests to ensure the fixes don't introduce new issues\n`;
  body += `- Feel free to modify the suggested changes as needed\n\n`;

  body += `### ğŸ“š Related Documentation\n\n`;
  body += `- [Nautilus Intelligence Core Docs](docs/nautilus-intelligence-core.md)\n`;
  body += `- [CI/CD Process](CICD_PROCESS.md)\n\n`;

  body += `---\n`;
  body += `*Powered by Nautilus Intelligence Core ğŸŒŠ*\n`;

  return body;
}

/**
 * Gets an emoji for the severity level
 */
function getSeverityEmoji(severity: string): string {
  switch (severity) {
    case 'critical':
      return 'ğŸ”´';
    case 'high':
      return 'ğŸŸ ';
    case 'medium':
      return 'ğŸŸ¡';
    case 'low':
      return 'ğŸŸ¢';
    default:
      return 'âšª';
  }
}

/**
 * Creates a comment on an existing PR with analysis results
 */
export async function commentOnPR(
  prNumber: number,
  analysis: AnalysisResult,
  options: {
    owner?: string;
    repo?: string;
  } = {}
): Promise<boolean> {
  const {
    owner = process.env.GITHUB_REPOSITORY_OWNER || 'RodrigoSC89',
    repo = process.env.GITHUB_REPOSITORY_NAME || 'travel-hr-buddy'
  } = options;

  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    console.error('âŒ GITHUB_TOKEN not found. Cannot comment on PR.');
    return false;
  }

  try {
    const octokit = new Octokit({ auth: token });

    const comment = buildAnalysisComment(analysis);

    await octokit.request('POST /repos/{owner}/{repo}/issues/{issue_number}/comments', {
      owner,
      repo,
      issue_number: prNumber,
      body: comment
    });

    console.log(`âœ… Comment added to PR #${prNumber}`);
    return true;
  } catch (error: any) {
    console.error('âŒ Failed to comment on PR:', error.message);
    return false;
  }
}

/**
 * Builds a comment with analysis results
 */
function buildAnalysisComment(analysis: AnalysisResult): string {
  let comment = `## ğŸ¤– Nautilus Intelligence Core - Analysis Results\n\n`;
  
  comment += `**Workflow:** ${analysis.workflowName}\n`;
  comment += `**Run ID:** ${analysis.workflowRun}\n`;
  comment += `**Status:** ${analysis.hasIssues ? 'âŒ Issues Detected' : 'âœ… No Issues'}\n\n`;

  if (analysis.findings.length > 0) {
    comment += `### ğŸ” Findings (${analysis.findings.length})\n\n`;
    
    analysis.findings.forEach((finding, index) => {
      const emoji = getSeverityEmoji(finding.severity);
      comment += `${index + 1}. ${emoji} ${finding.message}\n`;
    });
  } else {
    comment += `âœ… No issues detected in this workflow run.\n`;
  }

  comment += `\n---\n`;
  comment += `*Analyzed by Nautilus Intelligence Core ğŸŒŠ*\n`;

  return comment;
}
